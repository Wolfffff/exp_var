---
title: "Expression variation EDA"
output: html_notebook
---

A simple notebook for pulling RNAseq data from Expression Atlas and recount3

```{r}
library(ExpressionAtlas)
library(tidyverse)
library(limma)
library(sva)
library(edgeR)
library(ggplot2)
library(janitor)
library(foreach)
library(doParallel)
library(biomaRt)
library(ggfortify)

pca <- function(x, space=c("rows", "columns"),
                center=TRUE, scale=FALSE) {
  space <- match.arg(space)
  if(space=="columns") {x <- t(x)}
  x <- t(scale(t(x), center=center, scale=scale))
  x <- x/sqrt(nrow(x)-1)
  s <- svd(x)
  loading <- s$u
  colnames(loading) <- paste0("Loading", 1:ncol(loading))
  rownames(loading) <- rownames(x)
  pc <- diag(s$d) %*% t(s$v)
  rownames(pc) <- paste0("PC", 1:nrow(pc))
  colnames(pc) <- colnames(x)
  pve <- s$d^2 / sum(s$d^2)
  if(space=="columns") {pc <- t(pc); loading <- t(loading)}
  return(list(pc=pc, loading=loading, pve=pve))
}

experimental_metadata <- read_csv("expression_atlas_metadata.csv")
experimental_metadata <- experimental_metadata[-1,]
# experimental_metadata <- read_csv("recount3_metadata.csv")
plots_dir <- "data/"

feature_vec = list()
# feature_vec[["disease"]] = c("normal","control","",NA,"non inflammatory bowel disease control")


# Change the timeout because GTEx is huge!
options(timeout=1800)
```

Pull data as needed from recount3. This isn't currently in use but likely would be useful for making sure we have a standard processing pipeline.

```{r}
# Example pulling from recount3 -- not currently in use.
library(recount3)
human_projects <- available_projects()

proj_info <- subset(
    human_projects,
    project == "SRP166108" & project_type == "data_sources"
)
rse <- create_rse(proj_info)

map_to_cols <- function(s) {
  s %>%
  str_split("\\|", simplify = TRUE) %>% 
  str_split(";;", simplify = TRUE) %>% 
  as_tibble() %>%
  t() %>%
  row_to_names(row_number = 1) %>%
  repair_names()
}

convert_metadata_to_df <- function(sample_attributes) {
  meta <- lapply(sample_attributes,FUN=map_to_cols)
  meta <- dplyr::bind_rows(meta)
  meta <- DataFrame(meta)
  rownames(meta) <-rownames(colData(rse))
  return(meta)
}

metadata_df <- convert_metadata_to_df(colData(rse)$sra.sample_attributes)
rse@colData = metadata_df
```

```{r}
# atlasRes <- searchAtlasExperiments("",species = "Homo sapiens" )
#
accession_ids = experimental_metadata$id

rnaseqExps <- getAtlasData( 
  accession_ids
  # atlasRes$Accession[
  #   grep(
  #     "rna-seq",
  #     atlasRes$Type,
  #     ignore.case = TRUE
  #   )
  # ][1:50]
)

allExps <- rnaseqExps
exps <- names(rnaseqExps@listData)

exp_data = lapply(exps, FUN = function(x){return(allExps[[x]]$rnaseq)})
# exp_data = lapply(exps, FUN = function(x){return(allExps[[x]]$raw_counts)})
names(exp_data) <- exps
```

Generate a data frame containing all counts and another with all the metadata. NAs where metadata is missing.

```{r}
results_list <- list()
results_metadata_list <- list()
print(names(exp_data))

for (dset_name in names(exp_data)) {
  print(dset_name)
  dset = exp_data[[dset_name]]
  columns_to_ignore = unlist(strsplit(experimental_metadata[experimental_metadata$id == dset_name,]$columns_to_ignore,split=";"))
  
  metadata <- colData(dset)
  metadata <- data.frame(metadata)
  
  
  # Append dataset name and seq_id
  # metadata <- cbind(dataset = dset_name,metadata)
  # metadata <- cbind(seq_id = colnames(dset),metadata)

  counts = assays(dset)$counts
  print(dim(counts))
  
  # Filter at the individual level
  print(colnames(metadata))
  filtered_metadata <- metadata
  filtered_counts <- as_data_frame(counts)
  for (column in names(feature_vec)) {
    if (column %in% colnames(filtered_metadata)){
      filtered_counts <- filtered_counts[,filtered_metadata[,column] %in% feature_vec[[column]]]
      filtered_metadata <- filtered_metadata[filtered_metadata[,column] %in% feature_vec[[column]],]
    }

  }
  
  metadata <- filtered_metadata
  counts <- filtered_counts
  
  # Make sure we only use variables where there are 2 or more levels and build design matrix to incude
  # everything else
  # metadata <- metadata[!duplicated(metadata),]
  values_count <- sapply(lapply(metadata, unique), length) 
  metadata <- metadata[,names(metadata[,values_count > 1])]
  print(names(metadata))
  # metadata <- metadata[,!(names(metadata) %in% columns_to_ignore)] # Leave this in if you want to remove the AtlasAssayGroup
  b <- paste0(" ",names(metadata)[!(names(metadata) %in% c(columns_to_ignore))], collapse=" +")
  model <- as.formula(paste0("~ 0 +",b))
  print(paste0("~ 0 +",b))

  
  # metadata <- metadata %>% mutate(group_no = as.integer(technical_replicate_group))
  metadata$sample_id <- rownames(metadata)
  # metadata[metadata=="     "] = NA
  
  
  

  # design <- design[,-which(colSums(design) == 0)]
  
  
  print("Normalizing and estimating mean-variance weights")
  countdata.list <- DGEList(counts=counts,samples = metadata,genes=rownames(dset))
  if (names(metadata) %in% c("technical_replicate_group")){
      countdata.list <- sumTechReps(countdata.list,metadata$technical_replicate_group)
      metadata = countdata.list$samples
  }

  # recalc with updated metadata
  design <- model.matrix(model,data = countdata.list$samples)
  countdata.norm <- calcNormFactors(countdata.list)
  
  print("Trimming")
  cutoff <- 1
  drop <- which(apply(cpm(countdata.norm), 1, max) < cutoff)
  countdata.norm <- countdata.norm[-drop,] 
  
  # mod0 = model.matrix(~0,data=metadata)
  # mod <- design
  # svobj = sva(dat = countdata.norm,mod = design, mod0 = mod0,B=1)
  
  print("Voom!")
  jpeg(paste0(dset_name,"_voom.jpg"))
  countdata.voom <- voom(countdata.norm, design = design, plot=T)
  dev.off()
  
  results =  prcomp(t(countdata.voom$E))
  # library(RColorBrewer)
  # n <- length(unique(countdata.list$samples$technical_replicate_group))
  # qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
  # col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))
  tmp_plot <- autoplot(results)#,colour=col_vector[as.integer(countdata.list$samples$technical_replicate_group)])
  ggsave(tmp_plot,filename=paste0(dset_name,"_voom_PCA.jpg"))
  
  var_explained = results$sdev^2 / sum(results$sdev^2)
  tmp_plot <- qplot(c(1:10), var_explained[1:10]) +
    geom_line() +
    xlab("Principal Component") +
    ylab("Variance Explained") +
    ggtitle("Scree Plot") +
    ylim(0, 1)
  ggsave(tmp_plot,filename=paste0(dset_name,"_voom_scree.jpg"))
  
  n.cores = 16
  cuts <- cut(1:nrow(countdata.voom), n.cores)
  
  # countdata.voom <- countdata.voom[1:1000,]
  # countdata_resids <- removeBatchEffect(countdata.voom, covariates=design)
  
  values_count <- sapply(lapply(metadata, unique), length) 
  metadata <- metadata[,names(metadata[,values_count > 1])]
  PCs <- pca(countdata.voom$E)
  metadata$PC1 <- PCs$pc[1,]
  metadata$PC2 <- PCs$pc[2,]
  metadata$PC3 <- PCs$pc[3,]
  
  
  b <- paste0(" ",names(metadata)[!(names(metadata) %in% c(columns_to_ignore))], collapse=" +")
  model <- as.formula(paste0("~ 0 +",b))
  design <- model.matrix(model,data = metadata)
  
  cl <- makeCluster(n.cores)
  registerDoParallel(cl)
  list_batch_effects_removed <- foreach(x=levels(cuts), .combine='c', .multicombine=TRUE) %dopar% { 
    library(limma)
    effects_removed <- removeBatchEffect(countdata.voom[cuts == x,],covariates=design) 
    list(effects_removed)
  }
  
  countdata_resids <- do.call(rbind, list_batch_effects_removed)
  rownames(countdata_resids) <- countdata.voom$genes[,1]
  results =  prcomp(t(countdata_resids))
  # n <- length(unique(countdata.list$samples$technical_replicate_group))
  # qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
  # col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))
  tmp_plot <- autoplot(results)#,colour=col_vector[as.integer(countdata.list$samples$technical_replicate_group)])
  ggsave(tmp_plot,filename=paste0(dset_name,"_PCA_onresids.jpg"))

  var_explained = results$sdev^2 / sum(results$sdev^2)
  tmp_plot <- qplot(c(1:10), var_explained[1:10]) +
      geom_line() +
      xlab("Principal Component") +
      ylab("Variance Explained") +
      ggtitle("Scree Plot") +
      ylim(0, 1)
  ggsave(tmp_plot,filename=paste0(dset_name,"_scree_onresids.jpg"))

  
  print("Appending results and metadata to lists")
  results_list[[dset_name]] = countdata_resids
  results_metadata_list[[dset_name]] = metadata
}
save(results_list, file="results_list.RData")
save(results_metadata_list, file="results_metadata_list.RData")
```
