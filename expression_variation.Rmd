# Simple script showing how to pull data from Expression Atlas and recount3, normalize, and remove batch effects.

```{r setup, include=FALSE}
library(ExpressionAtlas)
library(tidyverse)
library(limma)
library(sva)
library(edgeR)
library(ggplot2)
library(janitor)
library(foreach)
library(doParallel)
library(biomaRt)
library(ggfortify)
library(patchwork)
library(cowplot)
library(clusterProfiler)
library(AnnotationDbi)
library(org.Hs.eg.db)
pak::pkg_install("rrcov")
library(rrcov)

source("functions.R")

# Set timeout to avoid failure when trying to download GTEx or other large datasets
options(timeout = 1800)
```

```{r}
experimental_metadata <- read_csv("expression_atlas_metadata.csv")
experimental_metadata <- experimental_metadata[-1,] # Remove the top row (GTEx) to lower the time cost when testing

# Load metadata from recount3
# experimental_metadata <- read_csv("recount3_metadata.csv")

plots_dir <- "data/"

# Setup filters for removing samples accordingly to the metadata
feature_vec <- list()
feature_vec[["disease"]] <- c("normal", "control", "", NA, 
                              "non inflammatory bowel disease control")
```


## recount3
```{r recount3}
# This is commented out as we're sticking with Expression Atlas for now.

# library(recount3)

# human_projects <- available_projects()

# proj_info <- subset(
#   human_projects,
#   project == "SRP166108" & project_type == "data_sources"
# )
# rse <- create_rse(proj_info)

# #
# map_to_cols <- function(s) {
#   s %>%
#     str_split("\\|", simplify = TRUE) %>%
#     str_split(";;", simplify = TRUE) %>%
#     as_tibble() %>%
#     t() %>%
#     row_to_names(row_number = 1) %>%
#     repair_names()
# }

# convert_metadata_to_df <- function(sample_attributes) {
#   meta <- lapply(sample_attributes, FUN = map_to_cols)
#   meta <- dplyr::bind_rows(meta)
#   meta <- DataFrame(meta)
#   rownames(meta) <- rownames(colData(rse))
#   return(meta)
# metadata_df <- convert_metadata_to_df(colData(rse)$sra.sample_attributes)
# rse@colData <- metadata_df
# }
```

## Expression Atlas

```{r}
accession_ids <- experimental_metadata$id

rnaseq_exps <- getAtlasData(accession_ids)

all_exps <- rnaseq_exps
exps <- names(rnaseq_exps@listData)

exp_data <- lapply(exps, FUN = function(x) {
    return(all_exps[[x]]$rnaseq)
})
names(exp_data) <- exps
```



## Main loop
```{r}
results_list <- list()
results_metadata_list <- list()
plot_list <- list()
print(names(exp_data))

dset_name = names(exp_data)[[6]]
# Loop over datasets
for (dset_name in names(exp_data)) {
  print(dset_name)
  dset <- exp_data[[dset_name]]
  columns_to_ignore = unlist(strsplit(experimental_metadata[experimental_metadata$id == dset_name,]$columns_to_ignore,split=";"))

  metadata <- colData(dset)
  metadata <- data.frame(metadata)

  counts = assays(dset)$counts
  print(paste0("Unfiltered count dimensions: ", dim(counts)[1], " x ", dim(counts)[2]))
  print(paste0("Unfiltered metadata dimensions: ", dim(metadata)[1], " x ", dim(metadata)[2]))

  filtered_data = make_filtered_data(counts, metadata)
  metadata <- filtered_data$metadata
  counts <- filtered_data$counts
  n_samples = dim(metadata)[1]
  metadata$sample_id <- rownames(metadata)

  print("Normalizing and estimating mean-variance weights")
  countdata.list <- DGEList(counts=counts, samples=metadata, genes=rownames(dset))
  if (any(names(metadata) %in% c("technical_replicate_group"))){
      print("Summing technical replicates")
      countdata.list <- sumTechReps(countdata.list,metadata$technical_replicate_group)
  }

  countdata.norm <- calcNormFactors(countdata.list)

  print("Trimming")
  cutoff <- 1
  drop <- which(apply(cpm(countdata.norm), 1, max) < cutoff)
  countdata.norm <- countdata.norm[-drop,]

  print("Voom!")
  # recalc with updated metadata
  values_count <- sapply(lapply(countdata.norm$samples, unique), length) 
  countdata.norm$samples <- countdata.norm$samples[,names(countdata.norm$samples[,values_count > 1])]

  # Removing columns with a crazy number of levels that mess everything up. 
  # (this is why we have random effects by the way)
  countdata.norm$samples = remove_large_factors(countdata.norm$samples)

  design <- make_desing_matrix(countdata.norm$samples)

  jpeg(paste0(plots_dir,dset_name,"_voom.jpg"))
  countdata.voom <- voom(countdata.norm, design = design, plot=T)
  dev.off()

  # Raw PCA plot
  pca_on_voom =  pca_plot(countdata.voom$E)

  screen_on_voom <- scree_plot(countdata.voom$E)
  
  countdata.list$samples = remove_redundant_features(countdata.list$samples)

  # Null model for SVA
  # mod0 = model.matrix(~1,data=countdata.list$samples)
  # We need to rebuild and ignore lib.size!
  
  # svobj = sva(countdata.norm$counts,mod0 = mod0,mod = design)

  print(paste0("Filtered count dimensions: ", paste(dim(countdata.list$counts), collapse = " x ")))
  print(paste0("Filtered metadata dimensions: ", paste(dim(countdata.list$samples), collapse = " x ")))

  # Batch effects
  countdata_resids <- removeBatchEffect(countdata.voom, covariates=design) 
  rownames(countdata_resids) <- countdata.voom$genes[,1]

  # PCA plot with Batch effects
  pca_on_resids <- pca_plot(countdata_resids)
  scree_on_resids <- scree_plot(countdata_resids)
  
  # Dropping outlier 
  rpca_resid <- PcaGrid(t(countdata_resids), 20, crit.pca.distances = 0.99)
  countdata.norm_noOut <- countdata.norm
  countdata.norm_noOut$counts = countdata.norm_noOut$counts[,rpca_resid@flag]
  countdata.norm_noOut$samples = countdata.norm_noOut$samples[rpca_resid@flag,]
  design_noOut <- make_desing_matrix(countdata.norm_noOut$samples)
  countdata.voom_noOut <- voom(countdata.norm_noOut, design = design_noOut)
  countdata_resids_noOut <- removeBatchEffect(countdata.voom_noOut, covariates=design_noOut) 
  pca_on_resids_noOut <- pca_plot(countdata_resids_noOut)
  
  # Batch effects With PC1
  
  PCs <- pca(countdata.voom$E)
  countdata.norm$samples$PC1 <- PCs$pc[1,]
  design_with_pc1 <-make_desing_matrix(countdata.norm$samples)
  
  countdata_resids_with_pc1 <- removeBatchEffect(countdata.voom,covariates=design_with_pc1) 
  rownames(countdata_resids_with_pc1) <- countdata.voom$genes[,1]
  


  # PCA plot with Batch effects and PC1
  pca_on_resids_with_pc1 <- pca_plot(countdata_resids_with_pc1)

  print("Writing figures")

  plt <- plot_grid(nrow=2, scale = 0.9, 
                   pca_on_voom + ggtitle("Uncorrected"), 
                   pca_on_resids + ggtitle("Known effects"), 
                   pca_on_resids_noOut  + ggtitle("Known effects, no outliers"),
                   pca_on_resids_with_pc1 + ggtitle("Known effects and PC1"))

  print("Appending results and metadata to lists")
  plot_list[[dset_name]] <- plt
  results_list[[dset_name]] <- countdata_resids
  results_metadata_list[[dset_name]] <- metadata
}

for(dset_name in names(plot_list)) save_plot(filename=paste0(plots_dir, dset_name,"_pca.png"), plot_list[[dset_name]], 
            base_height = 6, base_asp = 1.2, ncol = 2, nrow = 2)
save(plot_list, file = "plots_list.RData")
save(results_list, file = "results_list.RData")
save(results_metadata_list, file = "results_metadata_list.RData")
```